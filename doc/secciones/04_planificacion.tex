\chapter{Planificación}
\label{chapter:4}

En este capítulo se especifican todas las cuestiones relativas a cómo se ha
abordado el desarrollo del proyecto con respecto a la planificación,
metodologías e infraestructura de control de calidad. 

Primero, se hará una introducción sobre la ingeniería del \textit{software} y la
metodología de desarrollo que se ha utilizado para guiar el completo desarrollo
del trabajo. A continuación, se definirán las buenas prácticas para garantizar
el control de calidad y que servirán para hacer un correcto seguimiento del
desarrollo, además del papel central que tiene GitHub en este. Por último, se
hará un estudio comparativo sobre las diferentes herramientas que existen para
asegurar estas buenas prácticas y cuáles se usarán finalmente en el proyecto.

\section{Metodología de desarrollo}
El proceso de desarrollo de un \textit{software} moderno implica tener en cuenta
ciertas verdades como el hecho de que tanto el \textit{software} como las
personas que lo consumen han crecido en número en los últimos años, y con ello
la demanda en adaptarlo y mejorarlo, lo que implica que cada vez se tienen
requerimientos tecnológicos más complejos. Esto implica que se debe hacer un
esfuerzo para entender el problema antes de desarrollar una aplicación
\textit{software}, siendo el diseño una actividad crucial, y además debe tener
una alta calidad y facilidad para recibir mantenimiento
\cite{pressman_software_2015}. Es aquí donde entra la ingeniería del
\textit{software}, la cual nos permite guiar este proyecto para superar los
problemas mencionados y alcanzar la excelencia técnica.

La ingeniería del \textit{software} es el establecimiento y uso de principios
fundamentales de la ingeniería con objeto de desarrollar \textit{software}
confiable y eficiente. Es un proceso que forma la base para el control de la
administración de proyectos \textit{software}, y establece el contexto en el que
se aplican métodos técnicos, se generan productos (modelos, documentación,
código, etc.), se establecen puntos de referencia, se asegura la calidad y se
aborda al cambio de manera apropiada \cite{pressman_software_2015}.

Debido a que las metodologías tradicionales son incapaces de abordar un
desarrollo moderno y no consiguen permanecer en el tiempo, siendo muy mecánicas,
con largos ciclos de desarrollo que requieren una larga planificación fija y
extensa documentación que no garantizan un producto de calidad, surgen una serie
de nuevos métodos conocidos como ``ágiles`` \cite{abrahamsson2017agile}. Estos
nuevos métodos pretenden resolver todos estos problemas, centrándose
principalmente en el usuario final y en la calidad, y que gozan de una gran
popularidad en la actualidad. En la actualidad la mayoría de proyectos que se
desarrollan siguen metodologías ágiles y tienen una mayor tasa de éxito,
consiguiendo mejores resultados en productividad, calidad del \textit{software}
y entregas al cliente más frecuentes con cambios frecuentes
\cite{agilestatistics}.

La creación de la metodología \textit{Extreme Programming} dio inicio a muchas
otras que se siguen utilizando actualmente, y aunque existen muchos marcos de
trabajo concretos para dotar de agilidad a un desarrollo, todos siguen los
mismos principios \cite{abrahamsson2017agile}. Estos principios fueron definidos
en el año 2001 en el manifiesto ágil \cite{agilemanifesto} y siguen vigentes a
día de hoy. En estos principios se definen como valores centrales el priorizar
las relaciones entre personas y sus capacidades sobre procesos predefinidos,
entregar constantemente nuevas versiones del \textit{software} testeado y
mantener una estrecha relación con el cliente con la que evolucione el contrato
y necesidades del proyecto en el ciclo de trabajo en lugar de tener algo fijo e
inalterable.

Cuando hablamos de agilidad estamos hablando de estar preparado a los cambios y
de ofrecer métodos para que los procesos de desarrollo sean más rápidos y
ligeros. En \cite{abrahamsson2017agile} se dan las características que definen
el desarrollo ágil: modularidad en los procesos de desarrollo, cortos ciclos
iterativos de una a seis semanas que permitan verificaciones y correcciones
rápidas, adaptación a riesgos emergentes, desarrollo incremental que permita
construir una aplicación funcional en pequeños pasos y minimice riesgos,
orientado a las personas y trabajo de forma colaborativa y comunicativa. 

Todo el proyecto se ha planteado siguiendo estos principios. Se ha elegido así,
puesto que es el tipo de desarrollo más utilizado en la actualidad y es más
flexible que el clásico desarrollo en cascada con requisitos fuertes que
requieren tener toda la información desde el principio y ceñirse estrictamente a
un plan prefijado, cosa que dificulta mucho el desarrollo e impide ponerse a
trabajar cuanto antes. Este enfoque ágil se adapta perfectamente a un proyecto
individual como este en el que se tienen unos requisitos débilmente definidos
que irán evolucionando conforme se vaya desentrañando la complejidad de TvTropes
y analizándolo para desarrollar el scraper, debido tanto a la necesidad de
desarrollar una herramienta que se adapte a las diversas necesidades de los
usuarios como al carácter que tiene este trabajo como proyecto de aprendizaje.

La flexibilidad que da el desarrollo ágil a la hora de detectar cambios permite
tener un enfoque más centrado en la implementación del \textit{software} y menos
en la documentación, pudiendo adaptarse a las nuevas necesidades que vayan
surgiendo, para tener un producto final tecnológicamente puntero, eficiente,
eficaz y de calidad que cumpla lo mejor posible los objetivos.

Por tanto, siguiendo los principios ágiles y sus ventajas anteriormente
definidas, se resumen las características del desarrollo de este proyecto como
las siguientes:

\begin{itemize}
    \item El desarrollo es iterativo e incremental, en el cual se definen una
    serie de hitos (o entregables) que conforman un Producto Mínimamente Viable
    (PMV). Este PMV conforma una parte de la funcionalidad total que se quiere
    tener al final para cumplir los objetivos especificados, siguiendo la idea
    del desarrollo ágil de entregas constantes de pequeños incrementos. Los
    tests se asegurarán de que este incremento sea completamente funcional,
    garantizando su calidad.
    \item El desarrollo está organizado por una serie de historias de usuario,
    que se utilizan en las metodologías ágiles para especificar los requisitos
    desde el punto de vista del usuario y con las que posteriormente se extraen
    las tareas de desarrollo, que especifican más concretamente los problemas de
    implementación que se quieren resolver y de qué manera. Las historias de
    usuario permiten organizar el desarrollo del proyecto, siempre teniendo en
    cuenta si satisfacen al usuario, que es para quien se desarrolla.
    \item Se acepta que surjan problemas o nuevos requisitos, que se
    documentarán adecuadamente y se incorporarán a la planificación en mitad del
    desarrollo para adaptarse a esos cambios lo antes posible y siempre cumplir
    las necesidades de los usuarios.
    \item Se busca siempre la calidad del \textit{software}, usando para ello
    las mejores prácticas del lenguaje tanto en código como en su documentación,
    usando diversas herramientas que faciliten la automatización de tareas como
    la compilación o el testeo. Se va a desarrollar una herramienta que en
    última instancia será utilizada por usuarios reales y estos deben obtener el
    mejor producto posible.
\end{itemize}

En las siguientes secciones se profundizará más sobre estas características del
desarrollo, introduciendo y describiendo los hitos e historias de usuario.
Además, con el propósito de cumplir correctamente todos los principios ágiles
que se han definido se emplean varias herramientas y buenas prácticas para el
seguimiento del desarrollo que se describen a continuación.

\section{Seguimiento del desarrollo}
En esta sección se introducirá todo el ecosistema de desarrollo que se empleará
en todo el trabajo para asegurar que se cumplan los objetivos. Primero se
describirá cómo será el proceso de desarrollo del código y su seguimiento a
través de la plataforma GitHub como herramienta central para guiar el proyecto
en su totalidad. A continuación, se describirán los distintos hitos que se
pretenden alcanzar consecutivamente. Finalmente, se estudiarán y justificarán
una serie de buenas prácticas y herramientas que se seguirán al escribir el
código y testearlo para asegurar la calidad y desarrollar correctamente el
\textit{software}.

\subsection{GitHub}
Al ser un proyecto de \textit{software} libre el uso de Git y GitHub como
\textit{software} de control de versiones es imprescindible. Esto permite tener
un seguimiento cercano de todos los avances que se hacen tanto en el código como
en la documentación, que están ambos alojados en el repositorio
público\footnote{\url{https://github.com/jlgallego99/TropesToGo}}. Además de
esto también facilita el poder recuperar versiones anteriores del
\textit{software} en caso de algún fallo o cambio sustancial, por lo que es
ideal en una metodología ágil en la cual existen constantemente cambios.

Sin embargo, lo más importante es que se guía todo el proceso de desarrollo
mediante el repositorio de GitHub, teniendo en un mismo lugar todo lo necesario
para hacer un correcto seguimiento del estado del trabajo que se tiene en
cualquier momento mediante las herramientas que proporciona GitHub. El
funcionamiento es el siguiente:
\begin{itemize}
    \item Para llevar el seguimiento de las historias de usuario y tareas
    asociadas a ellas de la metodología de desarrollo ágil se han creado una
    serie de \textit{issues} en el repositorio de GitHub que especifican el
    trabajo que hay que realizar. Estos \textit{issues} servirán para saber en
    todo momento en qué trabajar y siempre están orientadas a resolver una
    historia de usuario, es decir, satisfacer sus necesidades.\\
    Cada vez que, en mitad del desarrollo, se necesite desarrollar algo o
    solucionar un problema se documenta en un \textit{issue} que especifica qué
    se quiere conseguir y entonces se trabaja en cumplirlo.
    \item Los distintos hitos estarán documentados en la sección de
    \textit{milestones}, indicando a modo de resumen el objetivo que se pretende
    alcanzar al tener ese producto funcional. Este es el principal artefacto
    para conocer el estado del proyecto, ya que cada hito indica una fecha
    límite para completarlo y una serie de \textit{issues} necesarias para
    completarlo por completo. Conforme estas se van completando se puede ver
    cuánto trabajo queda por hacer.
    \item Cada \textit{commit} es un avance en el código o la documentación, y
    en el mensaje se hará una pequeña indicación que sirva para saber qué se ha
    hecho para avanzar en el \textit{issue} al que hace referencia. De esta
    manera podemos saber en todo momento las decisiones que se han tomado para
    resolver una determinada tarea, teniendo un historial con todos los cambios.
    \item Todo el código y documentación que esté en la rama principal del
    repositorio se entiende que está probado y, por tanto, es completamente
    funcional. \\
    El código se desarrolla en ramas separadas a la principal, que hacen
    referencia a cada hito que se quiere alcanzar. Cada vez que se complete una
    tarea de desarrollo se hará un \textit{pull request} a la rama principal, y
    si pasa los flujos de CI configurados (los cuales se explicarán en próximas
    secciones) entonces se dará la tarea por completada y se tendrá una nueva
    versión funcional en la rama principal. 
\end{itemize}

Como podemos ver, mediante GitHub se tiene en un mismo sitio todo lo necesario
para el desarrollo: código, documentación y seguimiento del desarrollo para
saber siempre el trabajo que se tiene que hacer y poder avanzar de una forma más
cómoda en alcanzar los objetivos y satisfacer al usuario. 

\subsection{Hitos}
Como se ha visto anteriormente, uno de los principios básicos del desarrollo
ágil es el de ir creando rápidamente pequeños incrementos funcionales del
producto para ir teniendo un \textit{feedback} continuo del cliente, abordar
cambios y problemas lo antes posible y así minimizar el riesgo. Cada uno de
estos incrementos lo representamos como un hito, o \textit{milestone}, que
representa cada uno de los estados en los que va a ir evolucionando el
\textit{software}, conformando un Producto Mínimamente Viable. Cada PMV se
construye encima de los anteriores, por lo que no se avanza en el desarrollo
hasta que un hito quede completo en su totalidad. 

Cada hito equivaldría a un sprint, que es un ciclo de desarrollo corto (y
debería durar entre 1 y 6 semanas \cite{abrahamsson2017agile}) en el que se
desarrolla todo lo necesario para resolver los \textit{issues} convenientes, que
se deducen de las historias de usuario definidas. Estos \textit{issues} siempre
expresan un problema, cuya resolución satisface una historia de usuario, y por
consiguiente, al cliente. Al final del sprint se consigue un incremento de valor
en el producto que se está construyendo, es decir, un PMV. 

Estos hitos se van adaptando al propio proceso de desarrollo y van cambiando a
lo largo del trabajo conforme surgen nuevas necesidades al entender mejor el
dominio del problema o al necesitar productos mínimos intermedios antes de poder
trabajar en el siguiente. Es posible que para conseguir llegar a cierto
incremento haya que realizar antes otro que no se haya tenido en cuenta desde el
principio; la flexibilidad del desarrollo ágil nos permite hacer estos cambios
de planificación sin tener que replantear todo desde cero.

Un \textit{milestone} se considerará como completado una vez se hayan resuelto
todos sus \textit{issues} asociados. Al terminarlo y subir sus cambios a la rama
principal (tras un \textit{pull request} que haya sido aprobado por los flujos
de CI y el tutor) se lanzará un nuevo \textit{release}, es decir, el propio
incremento del producto que tendrá un número de versión asociado siguiendo la
nomenclatura del versionado semántico\footnote{\url{https://semver.org/}}.

Los hitos planificados para el desarrollo son los siguientes:

\subsubsection{M0. Configuración inicial - Objetivos, metodología e infraestructura de control de calidad}
En este primer hito se pretende abordar toda la planificación inicial y
preparación del proyecto para poder asegurar la calidad del mismo. Como producto
al final de este hito se definirán los hitos iniciales del proyecto y se tendrán
escritos los capítulos 1, 2, 3 y 4 de la documentación en los cuales se abordará
la descripción del problema a resolver, el estado del arte y toda la metodología
a seguir durante el proyecto. También se tendrá configurado el repositorio con
un comprobador ortográfico para la documentación, un gestor de tareas, los
sistemas de CI y los \textit{issues}, historias de usuario y \textit{milestones}
en el propio repositorio.

\subsubsection{M1. Modelización del problema}
Se obtendrá un producto mínimamente viable con el capítulo 5 de la
documentación, describiendo la metodología para modelar el problema durante el
desarrollo y analizando las partes más importantes de TvTropes, tanto el sitio
como la página. El modelo del problema permitirá definir tanto la organización
del código como las estructuras de datos e interfaces iniciales que permitan
resolver los dos próximos \textit{milestones} centrados en la extracción de
información de \textit{tropos} de las películas de TvTropes.

\subsubsection{M2. Scraper que entiende y testea una página de tropos de películas}
Con este hito se dará una primera versión funcional del \textit{scraper} que sea
capaz de encontrar el URL de una página sobre tropos de películas en TvTropes,
entienda su estructura y realice una serie de comprobaciones sobre ella para
confirmar que se pueda extraer información.

\subsubsection{M3. Scraper que extrae la información de una página de tropos de películas}
Se producirá un producto mínimamente viable con una primera versión del scraper
que extraiga la información de una página de tropos de películas que ha sido
previamente testeada y de la cual se entiende su estructura. El scraper
almacenará esta información en un fichero de datos estándar.

\subsubsection{M4. Araña que recorre el sitio}
Se tendrá desarrollada una araña que recorra todas las páginas de películas de
TvTropes y extraiga la información de sus tropos.

\subsubsection{M5. Actualizador de información}
El objetivo de este hito es poder actualizar la información ya extraída. Se
tendrá como producto mínimamente viable una araña que, al recorrer todas las
páginas, añada la información de las páginas nuevas que existen y actualice la
información de las antiguas.

\subsubsection{M6. Extracción de tropos de videojuegos, libros y series}
Como producto de este hito el scraper podrá encontrar páginas de tropos de
videojuegos, libros y series. Podrá entender y testar su estructura, así como
extraer la información de la página, almacenándola en un fichero de datos
estándar.

\subsubsection{M7. Aplicación de línea de comandos}
Este hito está enfocado en que el usuario final pueda usar el scraper. El
objetivo es obtener una aplicación de línea de comandos (CMD) que un usuario
pueda instalar y le facilite la interacción con el scraper, pudiendo obtener la
información de tropos completa o parcial según varias opciones y elegir entre
diferentes formatos de representación en los que obtener los datos.

\subsubsection{M8. Integración con fuentes de datos externas y extracción de metadatos}
Como producto de este hito el scraper será capaz de identificar qué medio
audiovisual de cualquier otra fuente de datos externa corresponde al que se ha
detectado en TvTropes, pudiendo sacar más información como el año de
lanzamiento, añadiendo a los datos obtenidos nuevos campos de metadatos.

\subsection{Desarrollo dirigido por pruebas}
El desarrollo dirigido por pruebas (TDD, de sus siglas en inglés \textit{Test
Driven Development}) es una de las principales y más importantes prácticas en el
marco de las metodologías ágiles para garantizar la calidad del
\textit{software}. Se trabaja bajo la idea de que cualquier código que no esté
testeado no es correcto, es propenso a fallos y, por tanto, todo el código debe
estar testeado para asegurar su buen funcionamiento y su calidad.

El objetivo del TDD es conseguir código limpio que funcione, y para ello es
necesario desarrollar primero los tests antes que el código de forma que al
estar trabajando en el código se tenga en cuenta qué tiene que cumplir. Esto
permite desarrollar de un modo predecible sabiendo siempre en qué momento se ha
terminado de desarrollar una tarea, ya que se ha realizado pensando en los tests
que tiene que pasar y estará testeada. 

El trabajar en un marco TDD da espacio a analizar bien el código, puesto que no
basta solo con desarrollar una función, sino que hay que estudiar bien su
funcionamiento para detectar todos los casos límite y probarlos. Además, tal y
como se busca en las metodologías ágiles, el objetivo del desarrollo dirigido
por pruebas es mejorar las vidas de los usuarios que usan el \textit{software}
\cite{beck2002driven}. En general, un código bien testeado se adapta a la
filosofía de cambio de las metodologías ágiles, ya que el reducir el riesgo
implica que el coste de abordar problemas o nuevas mejoras al desarrollo es
menor y puede suceder más frecuentemente.\\

La filosofía que se sigue a la hora de desarrollar tests es que estos son
automáticos y se desarrollan continuamente y siempre a la vez que el código. La
principal ventaja de esto es que ayuda a desarrollar bien el propio código al
tener en mente que los componentes que se desarrollan deben ser cohesivos y
tener un bajo acoplamiento para que escribir los propios tests sea una tarea
fácil.

Al desarrollar tests se sigue el \textit{mantra de TDD}, un orden definido por
Kent Beck \cite{beck2002driven} que consiste en: primero, hacer un test básico
que no funcione o no compile; segundo, arreglar el test para que funcione de la
forma más básica; y tercero, refactorizar y mejorar tanto el test como el código
sin cambiar la funcionalidad consiguiendo un código más simple y limpio. Todo
este proceso sigue la misma filosofía iterativa e incremental que la metodología
ágil que se usa en todo el desarrollo.\\

Por último, el desarrollo de los tests es también documentación, estando dentro
del propio lenguaje de programación. Los tests deberán ser legibles y
entendibles, centrándose en el comportamiento de las funcionalidades que evalúan
y, por tanto, permitirán expresar una correlación más directa con las historias
de usuario y la lógica de negocio.

\subsection{Integración continua}
La integración continua (CI, del inglés \textit{Continuous Integration}) es otra
práctica muy importante que se aplica en las metodologías ágiles y que está
estrechamente relacionada con la idea de cambio y de tener todo el código en un
repositorio central como el que se ha especificado. Las herramientas de
integración continua realizan comprobaciones automáticas sobre el código fuente
como paso previo al despliegue y crean algo ejecutable según las
especificaciones que se les dé, ya sea para crear un ejecutable del
\textit{software}, un test, un documento, un reporte, etc. En general se hace
referencia a cualquier proceso que automatice la construcción de una
aplicación.\\

En este proyecto se usan los sistemas de integración continua para automatizar
la ejecución de los tests y para comprobar ortográfica y gramaticalmente la
documentación al subir cambios a la rama principal, asegurando así la calidad
del \textit{software}, ya que todo el código que se tenga en producción estará
testeado. Esto además dota de agilidad al desarrollo, siguiendo con las mismas
ideas de metodologías ágiles, puesto que se tiene feedback en todo momento sobre
el estado de producción del código.

La razón de que se ejecuten estos sistemas para la rama principal es porque en
este proyecto se están desarrollando distintos productos mínimamente viables que
solamente estarán en la rama principal cuando se completen, y cuando no lo estén
se estarán desarrollando en alguna de las distintas ramas de desarrollo
correspondientes a cada hito, en la que no es necesario estar constantemente
ejecutando la integración continua. De esta manera aseguramos que todo el código
que esté en producción sea correcto porque ha pasado los tests
automáticamente.\\

Todos los sistemas de integración continua que se configuren se harán con GitHub
Actions para seguir con la idea de centralizar todo el desarrollo en el
repositorio de GitHub.

\section{Usuarios o partes interesadas}
Antes de definir las historias de usuario se analizan los usuarios o partes
interesadas en el proyecto (\textit{stakeholders}), para así poder enfocarlo en
resolver sus problemas. Este trabajo está orientado como un \textit{software}
que pueda integrarse en los procesos de ciencia de datos, por tanto, se ha
identificado un único usuario que representa el interesado en este ámbito:
\begin{itemize}
    \item \textbf{Investigador}: el investigador, o analista de datos,
    representa cualquier persona interesada en el estudio de los \textit{tropos}
    en narrativas para la generación de análisis y modelos de ciencia de datos y
    aprendizaje automático. Se asume que es una persona con cierto conocimiento
    informático y que sabe utilizar algún lenguaje de programación o herramienta
    de análisis de datos. Necesita tener la información estructurada y limpia de
    los tropos para construir modelos que le permitan hacer inferencias sobre
    las relaciones que tienen los tropos entre sí y llegar a conclusiones que
    sirvan para su investigación.
\end{itemize}

\section{\textit{User journeys}} 

Una vez definido el usuario para el que queremos desarrollar, es necesario
entenderlo para poder definir una serie de historias de usuario que expresen
correctamente sus necesidades. Para facilitar esto, desarrollamos una serie de
\textit{user journeys}, que describen, a modo de narración, todo lo que hace el
usuario desde que empieza a usar el \textit{software} hasta que termina, con el
objetivo de identificar distintas situaciones que nos permitan saber qué
desarrollar y de qué manera. En esta fase se tienen en cuenta aspectos como la
manera en la que accede al programa, para qué lo necesita, con qué frecuencia,
en qué contexto se encuentra, con qué dispositivo, los pasos para llegar a
solucionar su problema, etc. Esto nos dará una abstracción a alto nivel con la
que empatizar con los usuarios, entendiendo y representando cómo actuarían
finalmente al tratar con el \textit{software} que pretendemos construir. Este
enfoque permite desarrollar siempre con el usuario en mente, que es el objetivo
en el desarrollo ágil, y además ayuda a no solo contextualizar mejor las
historias de usuario, sino también a definirlas correctamente y poder generar
nuevas, al tener un punto del que partir.

Para desarrollar los distintos perfiles de usuario tenemos en cuenta los
artículos y líneas de investigación que se han ido mencionando a lo largo de
este documento. En estos se expresan las necesidades que tienen los
investigadores para tratar con \textit{tropos} y sus motivaciones, que a su vez
motivan a la creación de este proyecto y que sirven de ayuda para tener en mente
el tipo de personas a las que queremos ofrecerle una solución mediante
\textit{software}.

Para empezar con el proceso de generación de \textit{user journeys} definimos
los objetivos que se van a estudiar y que definen la razón de ser del
\textit{software} que se quiere desarrollar. Queremos estudiar los casos en los
que un investigador quiere obtener un conjunto de datos de películas con sus
\textit{tropos} y un conjunto de datos de toda la información de TvTropes, en
ambos casos para realizar algún tipo de investigación. A partir de esta premisa
buscamos varios caminos para que, mediante la experimentación, se lleguen a
cubrir varios mapas interesantes en los que el usuario alcance su objetivo.

\subsection{\textit{User journey} 1: Catedrático investigador en ciencia de
datos} 

Juan Benito García Martínez es un catedrático de la Universidad de Granada,
tiene 59 años y tanto la ciencia de datos como el aprendizaje automático entran
dentro de sus líneas de investigación.

\begin{itemize}
    \item Juan está trabajando en un artículo que estudia cómo los
    \textit{tropos} usados por películas influyen en el éxito que acabe teniendo
    tanto en taquilla como en crítica, estudiando también si existe algún cambio
    en los \textit{tropos} utilizados y el éxito cosechado a lo largo de los
    años.
    \item La fecha límite para entregar el artículo es dentro de una semana y
    aún necesita construir varios modelos de clasificación automática con tanto
    Python como R para cerrar el capítulo de análisis, así que necesita un
    fichero que contenga los datos que quiere. Está frustrado porque TvTropes no
    exporta su información y no tiene tiempo para trascribir tanta información a
    mano o construir una herramienta que lo haga por él.
    \item Decide buscar en internet para ver si alguien ya ha sacado esos datos.
    Encuentra varias recopilaciones de los datos de TvTropes que, sin embargo,
    datan del año 2016. Juan quiere que su artículo sea novedoso, ya que
    entiende que en los últimos años han salido muchas películas de renombre que
    han batido récords en taquilla. Tras una búsqueda más prolongada se
    encuentra con el repositorio de TropesToGo en GitHub, lee el \textit{README}
    del proyecto y se alegra al ver que le puede proporcionar justo lo que
    necesita: los datos de las películas y sus \textit{tropos} de TvTropes.
    Siguiendo las instrucciones del repositorio ve que es un programa que se
    puede instalar fácilmente con una sola orden, así que lo instala en su
    ordenador portátil.
    \item Siguiendo la documentación que hay en el repositorio encuentra
    rápidamente la opción que necesita. Juan ya ha usado aplicaciones de línea
    de comandos antes, por lo que, sin mucho problema ejecuta la orden exacta en
    el terminal especificando mediante varios \textit{flags} que quiere obtener
    un conjunto de datos en formato CSV para poder cargarlo con los dos
    lenguajes que va a utilizar y que quiere únicamente los \textit{tropos} de
    todas las películas que existan.
    \item Juan observa cómo en el terminal aparecen varios mensajes que le
    indican el estado del programa, que muestra cuántos \textit{tropos} lleva
    extraídos en cada momento. Juan está muy impaciente, pero de repente aparece
    un último mensaje que le indica que ya está listo su fichero, lo que le
    sorprende. Juan va a la ruta que ha especificado al ejecutar el comando y se
    encuentra con el fichero. Tras observarlo durante unos instantes está
    satisfecho, ya que entiende rápidamente cómo están codificados los datos y
    que contiene justo lo que necesita. Aún queda día, así que puede ponerse ya
    a trabajar. 
    \item Finalmente, ha podido entregar el artículo antes de tiempo gracias a
    lo rápido que ha conseguido el conjunto de datos y a que no ha necesitado
    realizar demasiadas tareas para limpiar los datos, puesto que ya estaban
    bastante utilizables. Contento y satisfecho, decide dejar instalado el
    programa en su ordenador por si necesitase otros datos de TvTropes para
    futuros análisis.
\end{itemize}

\subsection{\textit{User journey} 2: Estudiante de máster en ciencia de datos}

María Conde Alcaraz tiene 23 años y está terminando de estudiar el máster en
ciencia de datos en la Universidad de Granada.

\begin{itemize}
    \item María aprendió a utilizar TropesToGo al empezar a redactar su trabajo
    fin de máster, en el que tiene que construir un clasificador binario lo más
    preciso posible que permita identificar si un conjunto de \textit{tropos}
    pueden formar una serie de televisión que aguante en emisión varias
    temporadas.
    \item María se dio cuenta de que para su clasificador necesitaba más
    información de la que le provee el conjunto de datos que genera TropesToGo,
    principalmente el número de temporadas de una serie. Para solucionar esto,
    usó la información que ya posee, el título de la serie y el año en el que
    salió, para poder identificar la información adicional que necesita de otro
    lado. De esta manera, añade a su programa clasificador un módulo que se
    comunica con IMDB para sacar el número de temporadas que tiene cada una de
    las series que tiene en su conjunto de datos, añadiéndole un campo nuevo. Se
    siente aliviada, puesto que ha podido resolver fácilmente el problema
    gracias a la simplicidad y efectividad del conjunto de datos que tenía, que
    permitía relacionar las series fácilmente y no confundir las que tienen un
    mismo nombre.
    \item 6 meses después, queda un mes para la entrega del TFM y se da cuenta
    de que en ese tiempo TvTropes ha añadido muchísimos \textit{tropos} y
    series, que han tenido mucho tirón en ese periodo. María se siente. Sin
    embargo, vuelve a ejecutar TropesToGo con las mismas opciones que había
    utilizado anteriormente, y en muy poco tiempo el programa le informa de las
    series que se han actualizado en el conjunto de datos que ya tenía, por lo
    que, puede volver a ejecutar los modelos tal y como los tenía programados
    sin cambiar nada.
    \item María queda ahora muy satisfecha; podrá ir actualizando su conjunto de
    datos con el tiempo para que su clasificador automático entrene siempre con
    los últimos datos existentes.
\end{itemize}

\subsection{\textit{User journey} 3: Estudiante de un grado no relacionado con
la informática} 

Pablo Antonio Molina Ocaña es un estudiante del grado en estadística en la
Universidad de Granada. Es una persona joven, de 19 años, que únicamente usa un
ordenador muy básico para sus tareas de la universidad y es capaz de controlarlo
de forma básica en términos de usuario.

\begin{itemize}
    \item Pablo es un cinéfilo que pertenece a la comunidad de TvTropes, por lo
    que está muy familiarizado con lo que ofrece la página y tiene gran interés
    en ello. En clase le mandan un trabajo libre, y él decide que quiere hacerlo
    sobre los \textit{tropos} de sus películas favoritas y cómo se relacionan
    entre sí.
    \item Pablo es muy perezoso y no quiere escribir a mano toda la información
    que necesita de las películas que le gustan. Él está acostumbrado a tratar
    con el formato JSON y un \textit{software} que le permite sacar múltiples
    gráficas estadísticas basándose en el fichero que introduce. Buscando
    encuentra muy pocos conjuntos de datos de TvTropes, y la mayoría tienen más
    de lo que quiere y en otros formatos que desconoce, como CSV. Finalmente, se
    encuentra con TropesToGo y prueba a instalarlo en su ordenador portátil.
    \item Pablo no entiende muy bien cómo funciona el programa ni se ha parado a
    leer la documentación. Simplemente, lo ejecuta, y este le informa de lo que
    es el programa, lo que hace y le da varias opciones que él puede seguir.
    Introduce con su teclado que solo quiere obtener los \textit{tropos} de tres
    películas que le gustan. El programa le indica que debe introducir la URL de
    TvTropes de la película que quiere extraer, cosa que Pablo sí conoce, así
    que lo hace. Finalmente, el programa le ofrece varias opciones simples de
    cómo quiere obtener los datos, a lo que pablo selecciona la opción de JSON.
    \item Observa como rápidamente el programa le indica que ya está todo listo,
    y le informa de dónde puede encontrar el fichero JSON con los datos de la
    película que necesitaba. Pablo repite el proceso para las otras que necesita
    y, viendo lo sencillo que es, se emociona y decide extraer unas cuantas más
    de las que tenía pensadas en un primer lugar.
    \item Al final consigue los datos que necesitaba y puede terminar su trabajo
    sin demasiadas complicaciones, lo que deja a Pablo con una gran sensación de
    autorrealización.
\end{itemize}

\subsection{\textit{User journey} 4: Profesora de ingeniería informática} 

Paula Millán Sánchez es una profesora de 45 años en el máster en ingeniería
informática de la Universidad de Granada que imparte una asignatura sobre
tratamiento inteligente de datos.

\begin{itemize}
    \item Paula está preparando una práctica final para la evaluación de la
    asignatura que imparte. La práctica consiste en que los estudiantes analicen
    varias maneras de tratar con gran volumen de datos. Para esto, necesita
    proporcionarles un gran conjunto de datos en un formato que entiendan.
    \item Encuentra TropesToGo en su repositorio público de GitHub tras la
    recomendación de otro profesor, y decide ejecutar directamente el programa.
    La aplicación le da distintas opciones que le indican qué conjuntos de datos
    puede obtener y elige que quiere obtener un conjunto de datos con toda la
    información de TvTropes. Satisfecha, deja el ordenador ejecutándose y se va
    al gimnasio.
    \item Cuando vuelve, se da cuenta de que ha habido un apagón en su casa.
    Frustrada, enciende su ordenador de nuevo, muy agobiada sabiendo que
    seguramente haya perdido todo el progreso del programa.
    \item Siente incertidumbre porque no sabe si ha perdido todo el progreso que
    tenía. Vuelve a elegir las mismas opciones que antes y la aplicación le
    indica que ya tiene datos descargados en su ordenador y que seguirá
    descargando los que falten. Entusiasmada, Paula ve que la aplicación le va
    informando del progreso, que indica cuándo está extrayendo datos nuevos y
    cuándo está ignorando los que ya se tienen. El programa termina en 5
    minutos, informándola de que ya está todo hecho. Parece ser que antes del
    apagón estaba ya completado casi todo el proceso, así que solo ha requerido
    un poco más de tiempo. 
    \item Se siente alegre al no haber perdido el tiempo ejecutándolo todo desde
    el principio. Ahora Paula podrá mandarles el fichero con los datos a sus
    alumnos.
\end{itemize}

De estos \textit{user journeys} podemos sacar varias conclusiones, como por
ejemplo para qué pueden los usuarios necesitar los datos, que los investigadores
pueden utilizar distintos lenguajes de programación, que valoran muy
positivamente un conjunto de datos limpio y preparado para ahorrarles trabajo o
que quieren desarrollar análisis vanguardistas. También se hace referencia a
cómo interactúan con la aplicación final y las facilidades o dificultades que
pueden encontrar, como encontrar documentación que les permita saber cómo usar
la herramienta o que el propio programa les ayude a conseguir lo que necesitan
sin perder mucho el tiempo. Estas necesidades identificadas a lo largo de este
proceso se tendrán en cuenta a la hora de implementar el \textit{software}, para
cumplir con lo que los usuarios como los de este análisis esperan del producto
final, y se condensan a continuación en forma de historias de usuario, que serán
el principal artefacto que nos dirá cómo proceder con el desarrollo.

\section{Historias de usuario}
Sabiendo el problema que se quiere resolver y las partes interesadas se pueden
definir las historias de usuario que guiarán todo el desarrollo de principio a
fin, ayudando en la toma de decisiones para llegar a cumplir los objetivos.

\subsection{[HU01] Investigador - Obtener información sobre tropos}
Como investigador necesito poder obtener información sobre todos los tropos
existentes de cualquier tipo de medio audiovisual, en un formato estandarizado y
con una estructura definida para que sean de fácil acceso tanto a humanos como
programas para su análisis.

\subsection{[HU02] Investigador - Obtener un subconjunto de la información}
Como investigador necesito poder elegir qué parte de la información sobre tropos
quiero obtener, ya sea de un medio audiovisual concreto, todo un género, etc.

\subsection{[HU03] Investigador - Relacionar medios audiovisuales con fuentes externas}
Como investigador necesito obtener información de metadatos sobre cualquier
medio audiovisual, para lo cual necesito que los medios audiovisuales de los
cuales se han sacado sus tropos sean fácilmente identificables y se puedan
relacionar con su ficha en IMDB u otras fuentes de datos externas del mismo
tipo.

\subsection{[HU04] Investigador - Información actualizada}
Como investigador quiero que la información de tropos que obtenga esté lo más
actualizada posible, sepa cuándo se ha extraído y pueda obtenerla actualizada
cuando quiera para traer la nueva información que pueda existir.

\subsection{[HU05] Investigador - Representación de los datos}
Como investigador quiero poder elegir el formato en el que se represente el
conjunto de datos de entre los más comunes en ciencia de datos.

\subsection{[HU06] Investigador - Inmediatez de los datos}
Como investigador quiero obtener lo más rápido posible y sin complicaciones el
conjunto de datos con lo que necesito para poder centrarme cuanto antes en
analizarlos para mi trabajo.

\subsection{[HU07] Investigador - Recuperación de datos}
Como investigador necesito poder publicar el conjunto de datos obtenido, acceder
a él y recuperarlo en cualquier momento, incluso de forma offline.

%\section{Temporización} Una vez vistos los hitos que se esperan alcanzar en el
%desarrollo, los cuales conformarían cada uno un sprint con una fecha de inicio
%y de fin, podemos representar la temporización de todo el desarrollo en un
%diagrama de Gantt.

%A lo largo de todo el desarrollo se ha ido manteniendo contacto con el tutor
%tanto en tutorías presenciales como mediante mensajes por Telegram y GitHub
%para transmitir y resolver todas las dudas que han ido surgiendo, tanto del
%código como del propio documento.

\section{Elección de herramientas para el desarrollo}
Al llevar un proyecto de ingeniería del software a la práctica, en el cual se
tiene como primer objetivo la calidad, se requieren herramientas para poder
llevar a cabo todas las buenas prácticas descritas a lo largo de este capítulo. 

Es por esto que por último se comentarán todas las herramientas que se van a
utilizar para desarrollar el propio software, comenzando por el propio lenguaje
de programación en el que se escribirá el código. También se justificarán
herramientas para tener un buen ecosistema de desarrollo en el repositorio de
GitHub y cumplir con las buenas prácticas que se han descrito en las secciones
anteriores. Se justifica la elección de cada una comparando entre varias
alternativas, teniendo en cuenta las características concretas de este proyecto
y siempre con la calidad como criterio más importante para elegir la más
adecuada.

\subsection{Lenguaje de programación}
La principal herramienta a considerar para construir un \textit{software} es el
lenguaje de programación, concretamente uno que se adapte a las necesidades de
este proyecto. Se puede desarrollar un \textit{scraper} en cualquier lenguaje de
programación, sin embargo, debido a la naturaleza de aplicación en red de este,
se busca un lenguaje de programación que sea bastante afín a trabajar con el
protocolo HTTP y sea para poder gestionar el gran volumen de datos que se
tratará y además sea concurrente para intentar mejorar el ritmo de las
peticiones del \textit{crawler}, como se comentó en el estado del arte.

Teniendo en cuenta esto, se elegirá Go\footnote{\url{https://go.dev/}} como el
lenguaje de programación para desarrollar el \textit{scraper} de este proyecto.
Go es un lenguaje de programación libre, concurrente, rápido, fácil de utilizar
y con una sintaxis muy legible y moderna, que facilita mucho el reestructurar y
reescribir el código. Además, una de las principales ventajas de Go con respecto
a otros lenguajes es que tiene una biblioteca estándar amplia y con múltiples
funcionalidades que pueden ahorrar el usar bibliotecas de terceros, y un gran
ecosistema de bibliotecas modernas y bien mantenidas. Entre los casos de uso de
este lenguaje entran principalmente el desarrollo de aplicaciones de línea de
comandos y aplicaciones en red, por lo que se adapta perfectamente a este
trabajo. Además, es el lenguaje empleado por Google para desarrollar el
\textit{crawler} que indexa páginas para su motor de búsquedas
\cite{go_at_google}, así que se asume que es un lenguaje lo suficientemente
preparado para realizar este tipo de tareas.

Go es un lenguaje muy atractivo para desarrollar un \textit{scraper} debido a su
rapidez y eficiencia al ser un lenguaje compilado, mezclado con la facilidad de
programación que tiene al tener recolector de basura y opción de tipos
dinámicos. Estas características lo hacen una opción ideal para
\textit{scraping}, a diferencia de Python, el cual es otro lenguaje muy común en
este ámbito, pero que no tiene concurrencia en el propio lenguaje, no es tan
rápido y su gestión de errores es más compleja \cite{coleman_ultimate_2021}.

En relación con el lenguaje de programación, también es importante elegir el
entorno de desarrollo en el que se escribirá, ejecutará y probará todo el
código. Un buen entorno ayudará enormemente en el proceso de construcción del
\textit{software}, con tareas como refactorización, depuración, ejecución,
sugerencias, análisis, organización del código, etc. es imprescindible para
poder obtener un software de calidad y que todo el proceso de desarrollo sea lo
más agradable y libre de problemas posible.

La web oficial de Go recomienda principalmente tres editores con plugins
oficiales para desarrollar en Go: VS Code, GoLand y Vim. Por otro lado, una
encuesta oficial llevada a cabo en 2021 \cite{go_survey} revelaba, además de
varios datos con respecto al lenguaje como que el 92\% de los usuarios estaban
satisfechos con Go y el 75\% lo empleaban en el trabajo, qué entornos de
desarrollo eran los preferidos por la comunidad. Los dos entornos más populares
son los propios que se recomiendan oficialmente, VS Code y GoLand, quedando Vim
con un porcentaje muy bajo y siendo VS Code el más utilizado con diferencia, lo
cual es comprensible al ser una opción gratuita y muy utilizada en todos los
ámbitos. Sin embargo, GoLand pese a ser de pago sigue siendo una opción muy
preferida por la comunidad y demuestra la popularidad de la herramienta.

De entre estas dos alternativas se decide optar por GoLand. Su principal ventaja
es que, a diferencia de VS Code, el cual funciona mediante un plugin que puede
no funcionar siempre tan bien al ser un editor que tiene en cuenta muchos otros
lenguajes de programación, GoLand es un IDE enteramente dedicado a Go y tiene
funcionalidades más avanzadas debido a que es un entorno de desarrollo más
potente, con mayores funcionalidades y que nos permite centrarnos en el
desarrollo de un solo lenguaje. Además de esto, también se prefiere GoLand desde
el punto de vista educativo, ya que tiene interés aprender una herramienta
oficial centrada en un lenguaje y la Universidad de Granada ofrece una licencia
gratuita para todos los productos de JetBrains, incluido GoLand, por lo que el
precio no supone un problema. GoLand es una herramienta pensada para proyectos
más grandes como este y permitirá facilitar el desarrollo gracias a las
múltiples funciones que tiene, como autocompletar o refactorizar el código, que
hace mucho más fácil implementar cambios en un ambiente ágil como el que nos
encontramos.

\subsection{Gestor de tareas}
Dentro de los procesos de calidad del software entran los gestores de tareas,
que facilitan la automatización del resto de tareas del proyecto: instalación de
dependencias, ejecución de tests, compilación del código y documentación, etc.
Esta automatización garantiza que estas tareas se ejecuten con agilidad y se
puedan replicar en cualquier otro sistema fácilmente, ya que estarán descritas
en un fichero de configuración siguiendo la filosofía de la infraestructura como
código.

Debido a que existen multitud de gestores de tareas para proyectos, muchos de
ellos aptos para cualquier lenguaje de programación y con su propio modo de
describir y ejecutar tareas, es necesario un proceso de selección para el más
adecuado. En general un gestor de tareas no es una herramienta muy compleja,
todos son capaces de definir las tareas necesarias de una manera u otra. Por
esta razón se buscará una herramienta que sea simple, moderna, esté bien
documentada y tenga soporte actualmente con el objetivo de aprender una
herramienta que sirva para otros proyectos futuros y permita hacer lo
estrictamente necesario para el proyecto: compilar la documentación y el código
y ejecutar el software con sus tests. 

Además, puesto que es un proyecto libre cualquier persona puede acceder a él y
tener la documentación compilada en un PDF o ejecutar el software es
imprescindible para alguien que vea el trabajo por primera vez, por lo que así
que se tiene como otro punto a valorar que el propio gestor de tareas sea
autoexplicativo, es decir, tenga una manera rápida y sencilla de saber qué
tareas tiene el proyecto y ejecutarlas.

Al hablar de gestores de tareas el más destacable y utilizado es
\textit{make}\footnote{\url{https://www.gnu.org/software/make/}}, ya que es una
herramienta instalada por defecto en cualquier sistema Linux. \textit{Make} está
presente en cualquier ámbito de la programación, sirve para cualquier lenguaje y
en general para automatizar cualquier tarea de terminal. Sin embargo, se busca
un gestor de tareas más moderno, autodescriptivo y simple, que permita conocer
nuevas alternativas, y su \textit{Makefile} suele ser bastante complicado de
entender a primera vista y no se puede saber fácilmente cuáles son las tareas
que tiene definidas. Aún teniendo en cuenta esto se emplea \textit{make} en una
parte del proyecto, delegando en él la compilación de la documentación en LaTeX,
puesto que, es más fácil gestionar la compilación de algo que tiene tantos
ficheros usando las variables especiales de make. El gestor de tareas elegido
ejecutará con una orden el Makefile encargado de compilar el documento.

Otros de los más famosos son Gulp\footnote{\url{https://gulpjs.com/}} y
Grunt\footnote{\url{https://gruntjs.com/}}, sin embargo, son gestores de tareas
más centrados en el ecosistema de JavaScript, que requieren un mayor
conocimiento del lenguaje para describir su configuración, y se busca una
herramienta multilenguaje. Además, cuentan con multitud de \textit{plugins} que
hacen el gestor más complejo de lo necesario.

Existen opciones modernas como
\textit{Task}\footnote{\url{https://github.com/go-task/task}}, un gestor de
tareas muy simple que se define a sí mismo como una alternativa más fácil a
make, el cual es interesante porque está escrito en Go, el mismo lenguaje con el
que se escribirá el software de este proyecto. Tiene una sintaxis simple con
ficheros en formato YAML, el cual tiene la ventaja de que es un formato muy
común en infraestructura como código. Es un proyecto que se sigue manteniendo a
día de hoy, pero se ha decidido descartarlo porque no aporta tanta legibilidad
como el que finalmente se ha elegido, su fichero de configuración es más
complejo de confeccionar y tiene más funcionalidades de las realmente necesarias
para el proyecto por lo que no es tan simple. Sin embargo, es una opción muy
buena que se podría considerar para cualquier proyecto.

En el ámbito de los gestores de tareas de Go se ha visto
Realize\footnote{\url{https://github.com/oxequa/realize}}, que también usa
ficheros de configuración en formato YAML. Con él se pueden gestionar múltiples
proyectos a la vez y, puesto que está hecho para Go, tiene en cuenta todos los
comandos CLI del lenguaje para generar tareas asociadas. Se ha descartado por
las mismas razones que Task, además de que se busca un gestor multilenguaje y
para un solo proyecto, sus ficheros de configuración son demasiado largos, no
tiene demasiada documentación, y el proyecto parece abandonado viendo que el
último commit en el repositorio es de hace tres años y la última
\textit{release} es de hace cinco. Es por esto que no sería lo más ideal usarlo,
ya que, podría tener bugs o problemas para los que no haya soporte.

Finalmente, uno de los más llamativos y el cual se ha escogido para este
desarrollo es
\textbf{\textit{Mask}}\footnote{\url{https://github.com/jacobdeichert/mask}}, un
gestor de tareas simple, con buena documentación y ejemplos, que sigue teniendo
soporte a día de hoy y está en constante desarrollo. Su principal ventaja es que
aprenderlo implica poder aplicar este mismo gestor en cualquier otro proyecto
independientemente del lenguaje, además de que el propio fichero de descripción
de tareas, al estar escrito en \textit{markdown}, es a la vez legible para
humanos y ejecutable por el programa gestor de tareas lo cual es una manera muy
inteligente de combinar documentación y ejecución de tareas. Dentro del propio
fichero de configuración se puede ver tanto una descripción como las propias
órdenes que ejecuta para lanzar la tarea, teniendo una forma fácil de saber qué
hace exactamente. Cualquier persona que esté interesada en ver qué tareas tiene
el proyecto no tiene más que abrir el fichero \texttt{maskfile\.md} además de
que el fichero al abrirlo en GitHub se verá formateado, puesto que tiene un
lector de \textit{markdown}, centralizando todo aún más en el repositorio.

\subsection{\textit{Framework} de testing} En un entorno de desarrollo ágil hay
que asegurarse de que todo código esté completamente testado para garantizar su
calidad código que no está testeado es código que se considera que no
funciona. Para ello se deben escribir una serie de tests en el propio lenguaje
de programación que el resto del código y que sean legibles y correctos,
escritos antes que la propia funcionalidad, para que automáticamente pase unas
pruebas que garanticen qué partes del código funcionan y cuáles no, poder cerrar
\textit{issues} y saber qué construir a continuación.

Se busca un marco de trabajo para pruebas en Go en el que las aserciones sigan
el estilo BDD, es decir, permitan desarrollar unos tests más legibles desde el
propio código, lo cual facilita mucho el escribirlos y comprobarlos. El estilo
BDD se centra en el comportamiento de las funcionalidades que se evalúan, y esto
hace que se tenga una correlación más directa con las historias de usuario y el
ámbito del problema. Por tanto, se quiere un \textit{framework} de testing que
tenga estas características de BDD, sea libre, popular, con buena documentación
y siga manteniéndose a día de hoy, para evitar cualquier problema que pueda
surgir de usar herramientas obsoletas, más aún en un lenguaje moderno como Go en
el que constantemente salen nuevas funcionalidades y requiere mantenerse al día.

Go es un caso especial a diferencia de otros lenguajes, ya que tiene una
biblioteca estándar provista de multitud de funcionalidades muy bien mantenidas
y utilizadas, como el testing. La utilidad de línea de comandos \texttt{go test}
para ejecutar el código de tests y el paquete \texttt{Testing} para escribir el
propio test, permiten realizar pruebas de forma nativa en Go. Sin embargo, estas
pruebas no se escriben mediante aserciones, sino controlando errores y, por
tanto, no son tan legibles ni proporcionan un gran control o funcionalidad al
ser una utilidad básica del lenguaje.

Al ser parte del lenguaje, tenemos ya de base un método y herramienta oficial
para escribir y ejecutar tests, que además nos asegura buenas prácticas dentro
del lenguaje y buen soporte a lo largo del tiempo, es simple y se pueden
encontrar multitud de recursos debido a su popularidad. Sin embargo, se queda
corta, no da mucha versatilidad y no usa un estilo BDD, por lo que gran parte de
las bibliotecas de aserciones y frameworks que podemos encontrar se centran en
ayudar a la biblioteca estándar de varias maneras. Debido a esto, tener una de
estas bibliotecas o frameworks adicionales no descarta por completo su uso, sino
que a la vez se aprenderá también el propio de Go.

Se han estudiado las siguientes bibliotecas:
\begin{itemize}
    \item Testify\footnote{\url{https://github.com/stretchr/testify}} es una de
    las bibliotecas de aserciones más famosas para Go, sin embargo, es de estilo
    TDD, con unas aserciones más complejas y menos legibles, además de que es
    más parecida a la biblioteca estándar.
    \item Gocheck\footnote{\url{https://github.com/go-check/check}} es otra
    biblioteca de aserciones TDD. Es una alternativa a Testify que permite
    aserciones más complejas, sin embargo, el proyecto está abandonado y no es
    tan popular, además de que no es BDD y la documentación es muy escasa.
    \item La biblioteca Gopwt\footnote{\url{https://github.com/ToQoz/gopwt}}
    ofrece aserciones sencillas de tipo TDD y como principal característica
    tiene que permitir identificar en qué parte del código falla un test,
    facilitando el arreglar errores. El problema que tiene esta biblioteca,
    además de ser TDD, es que al igual que la Gocheck no es muy popular y lleva
    aún más años abandonada. 
    \item Goconvey\footnote{\url{https://github.com/smartystreets/goconvey}} es
    una de las bibliotecas de aserciones BDD más populares de Go y una de las
    que ofrece una funcionalidad bastante distinta al resto. El punto principal
    de esta biblioteca es que da un análisis muy extenso y profundo sobre los
    tests y los muestra generando una página web en lugar de en terminal. Es una
    muy buena opción que está mantenida y se podría considerar en otros
    proyectos, sin embargo, el código no resulta tan legible como otras
    alternativas y la posibilidad de idear aserciones personalizables junto al
    generar una web completa complica demasiado algo que se busca que vaya lo
    más al grano posible con lo que ya ofrezca. Además de esto, en el
    repositorio de GitHub se observan varios \textit{issues} abiertos haciendo
    referencia a que el resultado de los tests no siempre es del todo correcto.
\end{itemize}

Finalmente, se ha optado por usar
Ginkgo\footnote{\url{https://github.com/onsi/ginkgo}}. Es un \textit{framework}
de testing bastante popular y con muy buena y extensa documentación y ejemplos,
que además proporciona herramientas de cobertura de código, que podrían ser
útiles en el futuro si se decidiese analizar si los tests aseguran que la
totalidad del código está testeado. Aunque provee su propia utilidad para
ejecutar los tests, la propia utilidad de Go también funciona, por lo que es una
ventaja que no haga falta instalar ningún programa adicional. Esta herramienta
tiene varias ventajas por las que se ha elegido: da una salida de los tests muy
legible y bonita con colores para entender bien la división entre cada parte,
tiene una utilidad que permite generar un esqueleto de pruebas a partir de cada
paquete, para facilitar el desarrollo y permite un buen manejo de los errores y
las aserciones con funciones legibles al estilo BDD. Además, también tiene la
ventaja de que se pueden agrupar tests por un mismo tema, para ejecutarlos
separadamente y leerlos mejor. Es un \textit{framework} muy completo que se
adapta bien a un proyecto grande como este y aprenderlo significaría poder
emplearlo en cualquier otro proyecto que se desarrolle con el mismo lenguaje,
por lo que también tiene un gran interés personal como algo a aprender.

\subsection{Bibliotecas de scraping en Go}
Por último, necesitamos justificar el uso de herramientas para
\textit{scraping}, que son de gran importancia. El desarrollo de un
\textit{scraper} es siempre un problema que se puede abordar desde múltiples
ángulos y está centrado en una o varias páginas web, que pueden ser
completamente distintas de otras. En el \textit{scraping} se utilizan
herramientas y métodos que resuelvan un problema concreto, analizando cómo está
organizada una página concreta y qué problemas va presentando conforme se va
conociendo más de ella a fondo, por lo que en la mayoría de casos las
necesidades son específicas. Lo más importante en esta disciplina es tener a
nuestra disposición un buen número de herramientas y métodos para interaccionar
con las páginas web y superar los retos que ponen a usuarios no humanos
\cite{apress2018scraping}. En este caso necesitamos aquellas herramientas que
nos ayuden con los retos concretos que presenta TvTropes.

La web de TvTropes está formateada en HTML y eso hace que necesitemos una manera
de entenderlo y extraer su información. Los \textit{scrapers} exploran multitud
de páginas buscando información concreta, ya que no queremos toda sino
solamente la que necesitamos y descartar el resto, para ahorrar recursos y tener
un programa que cumpla el objetivo que se propone. Esta información está
contenida en una vorágine de texto de muchos tipos, entre etiquetas de HTML y
clases CSS, e incluso a veces escondidas por una capa de JavaScript que
dinámicamente cambia la información. Sin embargo, existen multitud de
bibliotecas que nos facilitan este proceso de análisis (o \textit{parsing} en
inglés) del código HTML, para extraer lo que queremos. En
\cite{apress2018scraping} se recomienda no analizar el HTML manualmente, sino
apoyarse de bibliotecas externas que lo hagan, ya que es algo que puede ser muy
complejo y se sale del ámbito del trabajo. No buscamos reinventar la rueda sino
tener una herramienta de apoyo para que el programa entienda la web y se pueda
desarrollar un buen \textit{scraper}.

Al igual que con el resto de herramientas se usa como criterio de elección
imprescindible el que tenga buena documentación y sea un proyecto libre con
soporte en la actualidad. No buscamos un \textit{framework} que lo haga todo,
sino bibliotecas que ayuden en el proceso sin trivializar el proceso de
desarrollar una solución, con el principal objetivo de aprender a desarrollar
tanto el \textit{scraper} como el \textit{crawler} de forma autónoma y separada,
teniendo un mayor grado de control sobre lo que se hace con cada una de ellas y
dejando abierta la posibilidad de ampliarlas con otras bibliotecas. La
biblioteca de análisis de HTML debe soportar selectores CSS dentro del lenguaje
de programación para encontrar y recuperar fácilmente los elementos de la página
que queremos. Debe ser capaz de analizar, estructurar y organizar un texto HTML,
pudiendo codificarlo en una estructura del propio lenguaje de programación con
la que poder trabajar más fácilmente. Además, se busca que la biblioteca sea
capaz de arreglar los posibles errores de sintaxis que pueda tener la web, y no
nos dé fallos al analizar el HTML de una web. Esta última razón apoya aún más la
idea de apoyarnos en una biblioteca, ya que aunque muchas páginas son
renderizadas por los navegadores, no siempre tienen un código HTML correcto (y
esto es algo que los navegadores entienden y corrigen). Además de esto, también
se busca una forma sencilla de realizar las peticiones HTTP y que permita
controlar las cabeceras, para obtener el texto HTML que posteriormente analice
la biblioteca de \textit{parsing}.

Además de esto, se tiene que tener en cuenta la posibilidad de tener que
gestionar el JavaScript de una página como se vio en el estado del arte.
Analizar todo el código JavaScript de una página y lo que hace en cada momento
puede resultar una tarea imposible, por lo que es necesario tener algún tipo de
herramienta que sea capaz de tener esto en cuenta. Otra recomendación de
\cite{apress2018scraping} es no ir directamente a por una biblioteca con un
motor de JavaScript, pero sí tenerlo en cuenta por si fuese necesario en el
futuro, ya que puede ser demasiado complejo usar una herramienta grande y
compleja para un problema que luego es más pequeño y simple. No siempre es
necesario que un \textit{scraper} gestione el JavaScript de una página; en
muchos casos basta con obtener el HTML base para obtener lo que se quiere. Como
se verá en la siguiente sección, al analizar la web de TvTropes observamos que
no tiene un uso intensivo de JavaScript que esconda algún tipo de información
que necesitemos y no hace falta interaccionar con la página directamente como si
se estuviese utilizando un navegador. Por tanto, como criterio adicional, se
añade que no es necesario que la biblioteca elegida tenga integrado un motor
completo de JavaScript, aunque sí debería permitir integrárselo en caso de ser
necesario. Es decir, buscamos una biblioteca que no nos impida hacer esto si
fuese necesario tras posteriores análisis.
% Esto es lo que creo ahora, en el caso de que luego en el siguiente milestone
% vea que no es el caso y resulte que sí que hace falta tratar JavaScript, se
% modificará esta sección.

Aunque como criterio de elección hemos decidido usar un analizador de HTML y no
un \textit{framework} que gestione todo el proceso de \textit{crawling} y
\textit{scraping}, cabe destacar la existencia de
\textit{Colly}\footnote{\url{https://github.com/gocolly/colly}}, una de las
herramientas más populares en Go para este propósito. \textit{Colly} proporciona
un \textit{framework} completo y rápido que, de forma tanto síncrona como
asíncrona, permite crear a la vez un \textit{scraper} y \textit{araña} en pocas
líneas de código. La principal desventaja de \textit{Colly} es que no interpreta
JavaScript y no sería posible integrarlo con otras herramientas que solucionen
esto. Esta opción se descarta con el objetivo de tener solo bibliotecas básicas
e imprescindibles, intentar desarrollar algo en lo que se tenga un mayor
control, separación explícita entre \textit{scraper} y araña, se pueda aprender
a desarrollar un \textit{software} de este tipo desde un nivel más bajo y no nos
impida el integrar otras herramientas en caso de necesitar gestionar la
interacción con la página y JavaScript. Si se escogiese \textit{Colly} desde el
principio, y luego resultase que necesitamos gestionar esto, tendría un gran
coste el refactorizar todo el código para adaptarse a una nueva herramienta, por
lo que desde el principio decidimos usar la opción más versátil posible.

Al hablar de bibliotecas para \textit{scraping}, independientemente del
lenguaje, la principal alternativa \textit{Beautiful
Soup}\footnote{\url{https://www.crummy.com/software/BeautifulSoup/bs4/doc/}}.
Esta es la principal biblioteca para este ámbito en Python y transforma los
contenidos HTML en una representación en árbol. Debido a su popularidad, existe
una alternativa igual para Go llamada
\textit{Soup}\footnote{\url{https://github.com/anaskhan96/soup}}. \textit{Soup}
es una muy buena opción para analizar HTML, ya que tiene una interfaz muy
similar a \textit{Beautiful Soup}, lo cual hace que sea más sencillo encontrar
recursos para ella al existir los de Python. Sin embargo, aunque se podría
considerar para este proyecto, se rechazará debido a que lleva descontinuada más
de un año y preferimos buscar una solución más popular y que funcione
correctamente, además de que no tiene demasiada documentación propia y, aunque
como se ha dicho se podría entender viendo ejemplos de Python, es bastante
posible encontrar problemas específicos de Go que serían difíciles de resolver
al no tener una documentación y un soporte dedicados.

Se ha hablado varias veces de la importancia de la biblioteca estándar en Go y
que contiene un gran número de paquetes con muchas funcionalidades. Entre ellas
está un analizador de HTML que, sin embargo, no es la mejor opción para este
caso. La biblioteca estándar de Go contiene el módulo \texttt{net/html} capaz de
analizar HTML que, sin embargo, devuelve nodos y no construye un árbol DOM que
tendría más funcionalidades y sería más fácil de recorrer, además de que no
permite el uso de selectores CSS para acceder a clases y extraer la información
más efectivamente, por lo que no es la mejor opción para resolver este problema.
Para algo tan central en el \textit{scraper} como es analizar el HTML, es
imprescindible elegir una herramienta que facilite el proceso todo lo que se
pueda, permita un mayor control sobre el código HTML, construya un DOM y soporte
los selectores CSS.

La biblioteca Goquery\footnote{\url{https://github.com/PuerkitoBio/goquery}}
supone una mejor alternativa con respecto a \textit{Soup}, y es la alternativa
que se elige finalmente. Es una biblioteca muy popular, con una sintaxis muy
sencilla, y que tiene las mismas funcionalidades que jQuery, la biblioteca de
manipulación y exploración de documentos HTML más conocida. Permite generar un
árbol del DOM completo con varias funcionalidades, entre ellas la posibilidad de
recorrerlo mediante selectores CSS. En el propio repositorio de Goquery se
informa que su API es completamente estable y no tiene errores, además sigue
teniendo cambios para pequeñas mejoras a día de hoy. Tiene una wiki y varios
ejemplos, tanto en su propio repositorio como en internet, ya que es una opción
generalmente preferida en proyectos sin \textit{Colly}.

Goquery suele ir en conjunto con el paquete \texttt{net/http} de la biblioteca
estándar, tanto en los \textit{scrapers} desarrollados en Go como en los propios
ejemplos oficiales. Todas las bibliotecas de terceros que realizan conexiones
HTTP tienen este paquete como base, y la mayoría de bibliotecas de
\textit{scraping} para Go también. Este paquete nos permite hacer peticiones con
diferentes verbos HTTP, modificar fácilmente las cabeceras, mantener la
conexión, etc. y todo de manera idiomática, completamente funcional y sin
necesidad de depender de terceros, ya que forma parte del núcleo de Go. Por
tanto, en este caso emplearemos el paquete \texttt{net/http} para gestionar la
conexión con TvTropes. 